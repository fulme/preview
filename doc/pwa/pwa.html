<h1 id="pwa">PWA应用实践</h1>
<h2 id="">简介</h2>
<p>Progressive Web App, 简称 PWA，是提升 Web App 的体验的一系列新方法/API，能给用户接近原生应用的体验。</p>
<p>PWA 的主要特点：</p>
<ul>
<li><strong>可靠</strong> - 在不稳定的网络环境下甚至断网的情况也能加载、呈现</li>
<li><strong>快速</strong> - 快速加载，快速、平滑的动画响应用户的操作</li>
<li><strong>粘性</strong> - 具有沉浸式的用户体验，可以安装到桌面，全屏展示，离线推送消息</li>
</ul>
<p>涉及到的新方法/API如下：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">Service Worker API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">Web Push API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest">Web App Manifest</a></li>
</ul>
<h2 id="serviceworker">Service Worker</h2>
<p>Service worker是一个注册在指定源和路径下的事件驱动的工作线程。
它采用JavaScript控制关联的页面，可以拦截并修改访问和资源请求。
Service worker作为工作线程运行，不能访问<code>DOM</code>，只能由<code>HTTPS</code>承载。</p>
<h3 id="-1">生命周期</h3>
<ul>
<li><strong>注册</strong> - 页面适当位置进行注册，避免影响业务代码的加载/执行</li>
</ul>
<pre><code class="javascript language-javascript">  window.addEventListener('load', function() {
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js', {scope: './'});
      }
  });
</code></pre>
<ul>
<li><strong>下载</strong> - 用户首次访问service worker控制的网站或页面时，service worker会立刻被下载，之后至少每24小时它会被下载一次</li>
<li><strong>安装</strong> - 下载完成后立即进行安装</li>
<li><strong>激活</strong> - 首次安装立即激活，之后的的安装需要等待旧的worker没有页面时候的时候才会停止旧的激活新的，也可以通过接口直接接活</li>
</ul>
<h3 id="-2">作用</h3>
<ul>
<li>后台数据同步</li>
<li>资源预加载</li>
<li>后台服务钩子</li>
<li>数据多页面同步</li>
<li>响应来自其它源的资源请求</li>
<li>自定义模板用于特定URL模式</li>
<li>在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的）</li>
</ul>
<p>接口层提供了<code>fetch</code>钩子函数及<code>cache</code>相关的存、取接口，可以自行设计缓存策略。
google开源了强大框架<a href="https://github.com/GoogleChrome/workbox">workbox</a>，提供了非常易用的接口调用及强大的可扩展性。</p>
<h2 id="webappmanifest">Web App Manifest</h2>
<ul>
<li>引入<code>manifest</code>文件</li>
</ul>
<pre><code class="html language-html">  &lt;link rel="manifest" href="/manifest.json"&gt;
</code></pre>
<ul>
<li><code>manifest</code>文件配置</li>
</ul>
<pre><code class="javascript language-javascript">  // 方便写注释，定义成一个js对象
  var manifest = {
    "scope": "/", // 配置文件作用域
    "background_color": "blue", // 显示在状态栏
    "theme_color": "red",
    "name": "完整的应用名称",
    "short_name": "应用名简称",
    "description": "应用描述，类似于meta中的description",

    "start_url": "",
    "display": "standalone", // standalone || fullscreen || minimal-ui || browser
    "orientation": "", // any || natural || landscape/portrait-primary/secondary
    "icons": [
      {
          "src": "icon/lowres.webp",
          "sizes": "48x48",
          "type": "image/webp"
        },
        {
          "src": "icon/hd_logo.ico",
          "sizes": "72x72"
        },
        {
          "src": "icon/hd_logo.svg",
          "sizes": "96x96 144x144 192x192 256x256 512x512"
        }
    ],

    "prefer_related_applications": true,
    "related_applications": [
      {
          "platform": "play",
          "url": "https://play.google.com/store/apps/details?id=com.example.app1",
          "id": "com.example.app1"
        }, {
          "platform": "itunes",
          "url": "https://itunes.apple.com/app/example-app1/id123456789"
        }
    ], // 获取对应原生应用的方式

    "lang": "",
    "dir": "", // ltr || rtl || auto
  }
</code></pre>
<h2 id="webpushnotification">Web Push Notification</h2>
<h3 id="-3">工作原理</h3>
<p>从顶层视角来看，主要分为三个步骤：</p>
<ol>
<li>客户端代码引导用户订阅消息推送</li>
<li>业务服务端触发消息推送的事件到用户</li>
<li>service worker 接收推送事件，并通过桌面通知方式通知用户</li>
</ol>
<p>但为了防止滥用、性能及安全性问题，实际的过程却并未以上所述的那么简单、明了，下面逐步详解相关的技术细节。</p>
<h4 id="-4">第一步，客户端</h4>
<p>客户端代码引导用户定于消息推送，在这之前需要生成<code>application server keys</code>，即一个公/私钥对，后面会讲。
然后调用<code>PushSubscription</code>接口，这个过程可以得到一个用户相关的订阅对象<code>subscription</code>，这个对象包含了该用户设备相关的信息。
然后把这个对象上传到业务服务器，业务服务器将此信息与用户建立对应关系（后续有用户相关消息需要推送的时候需要用到）</p>
<p>这个过程大致如下：
<img src="./img/browser-to-server.svg" alt="browser-to-server" /></p>
<p><code>subscription</code>对象结构如下：</p>
<pre><code class="json language-json">  {
    "endpoint":"https://fcm.googleapis.com/fcm/send/drcTF_vByoc:APA91bFd7EJfEsD_ebeWVInT_za6mL9QupzNsubnmjjF1-aw4ZSQJfq-1R42h0pjhL4OHe9v39khKHGEFZJdiWVPqSn6YFqQ2DEOBaUnOlLxKNCUz7SBa2ctJ85tKp0S7l3kQuFC2L5J",
    "expirationTime":null,
    "keys":{
      "p256dh":"BFVa344lqG-_d9kAl6ULKuixEngrG35nqyVM3JIoXFFyPmMVMNcDX-Yj21zvDYA4FIVJJ7xYfC6YY39nouQMNbs",
      "auth":"3XZotj1VMsfAHFMgE-BxtQ"
     }
   }
</code></pre>
<h4 id="-5">第二步，推送消息</h4>
<p>当业务有消息需要通知用户的时候，需要调用一个<code>push server</code>的<code>API</code>来实现。
这里我们需要理解几个问题：</p>
<ol>
<li><p><strong>第一个问题：</strong> 什么是<code>push server</code>，又是谁提供<code>push server</code>服务？<br />
<code>push server</code>就是接受网络请求，并把请求推送到合适的浏览器，简单的说就是一个消息转发服务。
浏览器可以使用任何的<code>push server</code>，由浏览器自动决定，不受业务控制，但没关系，因为每一个<code>push server</code>提供完全相同的<code>API</code>。
上面讲到，用户订阅成功后会得到一个<code>subscription</code>对象，此对象中的<code>endpoint</code>就是此次订阅对应的<code>API</code>地址，业务后端只需要调用这个地址的接口即可。
至于谁来提供<code>push server</code>，因为是标准化的协议，所以理论上谁都可以提供，如何实现可以参考<a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12">web push protocol</a></p></li>
<li><p><strong>第二个问题：</strong> <code>API</code>是什么样的？<br />
接口调用要求传递特定的<code>header</code>头部信息，及相关的二进制数据体，涉及到一系列的加密算法，实现相对比较繁琐。
好在主流的后端语言都有开源社区实现了底层的封装，业务侧可以直接基于别人的封装做更高层次的接口调用，协议细节参考<a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12">web push protocol</a>。</p></li>
</ol>
<ul>
<li><a href="https://github.com/web-push-libs/web-push">nodejs</a></li>
<li><a href="https://github.com/web-push-libs/web-push-php">php</a></li>
<li><a href="https://github.com/SherClockHolmes/webpush-go">go</a></li>
<li>…</li>
</ul>
<ol>
<li><strong>第三个问题：</strong> <code>API</code>能做什么？<br />
<code>API</code>是提供业务推送消息到用户的途径，并保证数据传输的安全。因为<code>push server</code>可以是任何人提供，所以数据必须加密。
<img src="./img/server-to-push-service.svg" alt="server-to-push-service.svg" /></li>
</ol>
<h4 id="-6">浏览器响应推送事件</h4>
<p><code>service worker</code>通过监听<code>push</code>事件，得到消息体，并可以通过桌面通知<code>notification</code>通知用户
<img src="./img/push-service-to-sw-event.svg" alt="" /></p>
<h2 id="-7">浏览器支持现状</h2>
<ul>
<li>service worker
<img src="./img/service-worker-compatibility.png" alt="service worker compatibility" /></li>
<li>Web App Manifest
<img src="./img/web-app-manifest-compatibility.png" alt="Web App Manifest compatibility" /></li>
<li>Web Push
<img src="./img/web-push-compatibility.png" alt="Web Push compatibility" /></li>
</ul>